/*
** $Id: lua.c $
** Lua stand-alone interpreter
** See Copyright Notice in lua.h
*/

#include "lua/lprefix.h"

#include <stdio.h>
#include <stdlib.h>

#include <signal.h>

#include "lua/lua.h"
#include "lua/lauxlib.h"
#include "lua/lualib.h"

#include <math.h>
#include <ctype.h>
#include <string.h>

//#include "lfrac.h"
#include "lpoint.h"
#include "lload.h"
#include "lbind.h"

#include "config.h"

/*
#define READERBUFSIZE 200
#define READSIZE 50 
#define NUMBUFSIZE 50
*/

//static lua_State* globalL = NULL;

static const char* progname = "main.lua";

/*
** Hook set by signal function to stop the interpreter.
*/
//static void lstop (lua_State* L, lua_Debug* ar) {
//  (void)ar;  /* unused arg. */
//  lua_sethook(L, NULL, 0, 0);  /* reset hook */
//  luaL_error(L, "interrupted!");
//}


/*
** Function to be called at a C signal. Because a C signal cannot
** just change a Lua state (as there is no proper synchronization),
** this function only sets a hook that, when called, will stop the
** interpreter.
*/
//static void laction (int i) {
//  int flag = LUA_MASKCALL | LUA_MASKRET | LUA_MASKLINE | LUA_MASKCOUNT;
//  signal(i, SIG_DFL); /* if another SIGINT happens, terminate process */
//  lua_sethook(globalL, lstop, flag, 1);
//}


/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message (const char* pname, const char* msg) {
  if (pname) lua_writestringerror("%s: ", pname);
  lua_writestringerror("%s\n", msg);
}


/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report (lua_State* L, int status) {
  if (status != LUA_OK) {
    const char* msg = lua_tostring(L, -1);
    l_message(progname, msg);
    lua_pop(L, 1);  /* remove message */
  }
  return status;
}

/*
** Message handler used to run all chunks
*/
//static int msghandler (lua_State* L) {
//  const char* msg = lua_tostring(L, 1);
//  if (msg == NULL) {  /* is error object not a string? */
//    if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
//        lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */
//      return 1;  /* that is the message */
//    else
//      msg = lua_pushfstring(L, "(error object is a %s value)",
//                               luaL_typename(L, 1));
//  }
//  luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
//  return 1;  /* return the traceback */
//}

static int call_main_program(lua_State* L)
{
    int status = luaL_loadfile(L, OPC_HOME "/" "main.lua");
    return status;
}

int main (int argc, char** argv) {
    lua_State* L = luaL_newstate();  /* create state */
    if (L == NULL) 
    {
        l_message(argv[0], "cannot create state: not enough memory");
        return EXIT_FAILURE;
    }

    luaL_checkversion(L);  /* check that interpreter has correct version */
    luaL_openlibs(L);  /* open standard libraries */
    open_lpoint_lib(L);
    lua_gc(L, LUA_GCGEN, 0, 0);  /* GC in generational mode */

    // create _load_module and _get_opc_home()
    lua_pushcfunction(L, opc_load_module);
    lua_setglobal(L, "_load_module");
    lua_pushcfunction(L, opc_get_home);
    lua_setglobal(L, "_get_opc_home");

    // create bind()
    lua_pushcfunction(L, lbind);
    lua_setglobal(L, "bind");

    // create global argument table
    lua_newtable(L);
    for(int i = 1; i < argc; ++i)
    {
        lua_pushstring(L, argv[i]);
        lua_rawseti(L, -2, i);
    }
    lua_setglobal(L, "arg");

    int status = call_main_program(L);
    if (status == LUA_OK) {
        status = lua_pcall(L, 0, 0, 0);
    }
    if(status != LUA_OK) 
    {
        report(L, status);
        return 0;
    }
    lua_close(L);
    //return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
    return EXIT_SUCCESS;
}

