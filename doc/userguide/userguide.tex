\input{../preamble}

\title{OpenPCells}
\subtitle{User Guide}
\author{Patrick Kurth}

\begin{document}

\maketitle
\begin{abstract}
    \noindent This is the official documentation of the OpenPCells project.  It is split in several different files for clarity. 
    This document is the general userguide for everyday usage, installation and related topics. It also includes a quick start for the impatient, which is situated
    at the beginning of the document, \emph{before} the introduction.
    If you are looking for a guide and documentation on the creation of parametrized cells, consult the celldesign manual.
    If you want to now more about the technical details and implementation notes, look into the technical documentation.
\end{abstract}

\tableofcontents

\section{Quick Start}
If you did not do this yet, clone the repository:
\begin{shellcode}
    $ git clone https://github.com/patrickschulz/openPCells
\end{shellcode}
Go to the repository, in the main directory is a file called \shellinline{opc}, which is the main program.

Check that you have a working lua interpreter by invoking \shellinline{lua}. You should get a message similiar to
\begin{shellcode}
    $ lua 
    Lua 5.3.3  Copyright (C) 1994-2016 Lua.org, PUC-Rio
    > 
\end{shellcode}
although the version can be different. Supported versions are 5.2 and 5.3 (both tested), but it is expected that every 5.x should work.

Now run the program:
\begin{shellcode}
    $ lua opc
\end{shellcode}
You should see the following message:
\begin{shellcode}
    no technology given
\end{shellcode}
This indicates that everything is working fine. In order that your toolchain can find all modules, you have to modify your \shellinline{LUA_PATH}. This depends on the type of your
shell. For bash/zsh:
\begin{shellcode}
    export LUA_PATH=";;/path/to/pcells/?.lua;/path/to/pcells/?/init.lua"
\end{shellcode}
For (t)csh:
\begin{shellcode}
    setenv LUA_PATH ";;/path/to/pcells/?.lua;/path/to/pcells/?/init.lua"
\end{shellcode}
The semicolons are important, and of course you need to adapt the path to the OpenPCells directory. 

Now call the program from a different location with all the needed data: technology, interface and cell. Since skywater130 is open source, the repository includes a
draft of technology files for it, which is at least enough to test the setup. However, other technologies are under NDA so we can't provide any technology files.
Most likely you will have to write them yourself, which is not too hard. See the guide about writing technology files. Let's call the program:
\begin{shellcode}
    opc skywater130 gds transistor
    # or
    opc skywater130 virtuoso transistor
\end{shellcode}
The gds interface creates a \shellinline{openPCells.gds} file, the virtuoso interface a \shellinline{openPCells.il}, which can be read with a text editor.

\section{Introduction}
Semiconductor technologies from the perspective of a designer of integrated circuits is a set of layers, in which shapes are created to make up the physical
implementation of integrated circuits, the so-called layout. It is a long and complex way to get to a final layout that can be sent to the foundry: The designer has
to start with an abstract schematic, check for all sorts of mistakes, processing mismatches, outer influences and so on and finally create the layout from the
schematic. The last activity for itself is quite complex and can take a lot of time. Designers have to place individual cells such as transistors or passive
components and connect them with interconnection metals. Then the layout has to be checked against design rules and for correctness (layout versus schematic).
The foundry supports designers by offering a process design kit (PDK), which includes parameterized cells (pcells). Sometimes the pcells have not the needed
flexibility or certain types are not available (often an issue for RF designs with lots of passive components), so that designers have to built them themselves.
Beside a static solution, pcells can of course also be built by designers, however, this can get quite complicated with a lot of edge cases. Furthermore, there are
basically two ways of implementing pcells: in cadence virtuoso by using SKILL (a proprietary language based on lisp) or in python with pycells, developed by ciranova
(now synopsys). Cadence pcells are quite closed, since you can only really access them with virtuoso and they are bound to one technolgy. Pycells are more open as
they are developed in python, however, you still have to register with synopsys to access the tools and the cells are still bound to one technology. Furthermore,
both techniques are linked to open access, the cell system IC designs are developed in nowadays. Despite the name, open access is not really open. You have to be
part of the consortium to access the standard.

In general, pcells and pycells function the same way: they are implementations of the open access abstract pcell interface, which is a good idea in theory, but has
some problems in practice. In my opinion, designers don't need pcells, that is, cells that can be parameterized even after they have been placed but \enquote{pgens}
(parameterized cell generators, although I won't name it like that): programmble generators that can create certain cells. If you need to change anything later on,
you have to re-generate it. To understand why this is beneficial you have to now something about IC layout and creating tape-outs. In short: pcells (as opposed to
\enquote{pgens}, so pcells and pycells) save all the code, parameters and stuff that is needed to generate that. If you loose any referenced functions (or more
likely: your colleague doesn't have it) or you change anything afterwards, it changes your design. Of course you can stream out the layout to GDS (which you have to
do anyways for the foundry) but this removes the parameterized part, also removing the \enquote{advantage} of pcells.

Besides problems with persistence and sharing of designs, pcells also are inherently technology-bound. Every PDK comes with its own set of pcells, which can be
annyoing.

This project aims at solving all these problems. We want to built technology-independent cell generators that can be easily accessed from any tool (open or closed
source), but are tool-independent. Therefor the entire project is implemented in an easy-to-learn-install-and-embed language (lua) without any dependencies at all. A
framework for writing tool interfaces is provided as well as templates for technology files. The project comes with a set of predefined cells which are actively
maintained and developed.

\section{Installation}
The OpenPCells project aims to have zero dependencies and be compatible with several available versions of lua. This should make the installation as easy as
possible.

\end{document}

% vim: ft=tex
