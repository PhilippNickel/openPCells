\input{../preamble}

\title{OpenPCells}
\subtitle{PCell Design Guide and API}
\author{Patrick Kurth}

\begin{document}
\maketitle
\begin{abstract}
    \noindent This is the official documentation of the OpenPCells project.  It is split in several different files for clarity. This document provides an overview
    of the creation of PCells in the OpenPCells environment as well as a detailed API documentation.  If you are looking for a general overview of the project and
    how to use it, start with the user guide, which also contains a tutorial for getting started quickly. If you want to know more about the technical details and
    implementation notes, look into the technical documentation.
\end{abstract}

\tableofcontents

\section{PCell Creation -- Introductory Examples}
We will start this documentation by a series of examples to show the main features and API functions. The to-be-created cells will get increasingly complex to
demonstrate various features.

Every cell is defined by a function where all shapes making up the shape are described. This function gets called by the cell generation system, which passes the
main object and a table with all defined parameters. The name for this function is \luainline{layout()}. Additional functions such as \luainline{parameters()}
are also understood.

\subsection{Simple Rectangle}
The first example is a simple rectangle of variable width and height. As mentioned, all the code for the rectangle resides in a function \luainline{layout()}.
The parameters of the cell are defined in a function \luainline{parameters()}, which is optional in theory, but since we're designing pcells, there is not much point
of leaving it out. In \luainline{layout()}, we receive the main object and the defined parameters. Here we can modify the object based on the parameters.

The simple rectangle looks like this:
\luafilelisting{code/simple_rectangle.lua}
Let's walk through this line-by-line (sort of). First, we declare the function for the parameter definition:
\luafilelisting[firstline = 2, lastline = 2]{code/simple_rectangle.lua}
In the function, we add the parameters, here we use the width and the height of the rectangle:
\luafilelisting[widthgobble=4, firstline = 3, lastline = 6]{code/simple_rectangle.lua}
We can add as many parameters as we like (\luainline{pcell.add_parameters()} accepts any number of arguments). For every argument, the first entry in the table is
the name of the parameter, the second entry is the default value. This is the simplest form, we can supply more information for finer control. We will see some
examples of this later on.

The default value for both parameters is 100, which is a \emph{size}, meaning it has a unit. Physical/geometrical parameters like width or height are specified
in nanometers.\footnote{Well, this is not entirely sure. Only integers are allowed and the base unit is assumed to be nanometer. This is also
currently reflected for example in the GDSII export, where the scaling is done approriately. However, it is planned that this will change in the
future, making the base unit in opc arbitrary.}

This is all for the \luainline{parameters()} function, so let's move on to \luainline{layout()}. This functions takes two arguments: the main object that will be
placed in the layout and the table with parameters for the cell (which already includes any parsed arguments given before the cell creation).

We can name them in any way that pleases us, the common name used in all standard cells distributed by this project is \luainline{_P} (as hommage to the global
environment \luainline{_G} in lua).
Of course it is possible to \enquote{unpack} the parameters, storing them in individual variables, but for cells with many parameters this rather is a bloat.
\luafilelisting[widthgobble = 0, firstline = 10, lastline = 10]{code/simple_rectangle.lua}

Now that we have all the layout parameters, we can already create the rectangle:
\luafilelisting[widthgobble = 4, firstline = 12, lastline = 12]{code/simple_rectangle.lua}
There is a lot going on here: We use the \luainline{geometry.rectangle} function to create a rectangle with with and height (third and fourth argument).
Since we are creating shapes of IC geometry, we have to specify a layer.
But we also want to create technology-independent pcells, so there is a generics system for layers.
Right now we are just using the \luainline{generics.metal} function, which takes a single number as argument.
\luainline{generics.metal(1)} specifies the first metal (counted from silicon), you can also say something like \luainline{generics.metal(-2)}, where \luainline{-1} is the index of the highest metal.
Lastly we pass the main object as first argument to the function, which places the rectangle within this object.

%\luainline{merge_into_shallow} is a \emph{method} of objects and needs a little explaining of the object system.
%As mentioned earlier, every geometry function creates what is called an object.
%An object is a collection of shapes, where each shape is made up of a layer-purpose-pair and points (which can currently be interpreted as rectangles or polygons).
%The cell generation systems expects all created shapes to be merged into the main object passed as argument (\luainline{obj} in this case).
%The function postfix \emph{shallow} is a hint towards cell hierarchies, where cells contain children, which can again have children and so on.
%Shallow in this case means that we only regard shapes that are in the referenced cell, not in the children.

This cell can now be created by calling the main program with an appropriate export and technology. Note that there's another manual about that, so we won't get
into any details here. The simplest call would be something like:
\begin{shellcode}
    opc --technology opc --export gds --cell simple_rectangle
\end{shellcode}

\subsection{Array of Rectangles}
Now that we know how to create a rectangle, we want to create an entire array, that is a rectangular area made up of several individual rectangles. This could be
used for example as filling. We will setup the cell exactly as before, we only have to add two new parameters: the repetition and the pitch (we will start with
quadratic arrays with equal pitch in both directions):
\luafilelisting[firstline = 1, lastline = 8]{code/rectangle_array.lua}
The default arguments are \num{200} for the pitch and \num{10} for the number of repetitions, which creates a ten-by-ten array of rectangles with a spacing of
\num{100} and a width and height of \num{100}. Again, remember that we work in nanometers here.

For the repetition we could use a loop to create the individual rectangles, but we also have to move them to their correct position.
The \luainline{geometry.rectangle} function takes a shift in x and y direction as fifth and sixth argument.
We have to calculate the correct offset, which results in:
\luafilelisting[widthgobble = 4, firstline = 12, lastline = 21]{code/rectangle_array.lua}
This loop is cumbersome as it has to be set up and furthermore the calculation of the offset for the rectangles is done by hand.
The function \luainline{geometry.rectangle} already can do what we need, as it can take the repetition and pitch in x and y as additional arguments.
This places repeated copies of a template rectangle (with width and height) with their center in the origin.
The full interface of \luainline{geometry.rectangle} is:
With it, we can replace the whole loop construct with:
\luafilelisting[widthgobble = 4, firstline = 24, lastline = 28]{code/rectangle_array.lua}
With this, the whole cell looks like this:
\luafilelisting{code/rectangle_array.lua}
Now you already now how to create simple rectangles and rectangle arrays with generic layers.
As integrated circuits are mostly made up of rectangles, one can already built a surprising amount of pcells.
However, we have to discuss how we can create layers other than metals, vias and shapes with more complex outlines than rectangles.
We will talk about that in the remaining cell tutorials.

\subsection{Metal-Oxide-Metal Capacitors}
Many technologies don't have so-called metal-insulator-metal capacitors (mimcaps), so the standard way to implement capacitors is be using interdigitated metals.
Let's do that. As before, we set up the pcell. Useful parameters are the number of fingers, the width and height of the fingers and the spacing in between.
Furthermore, we shift one collection of fingers (one plate) up and the other down to separate them and connect them together.
Lastly, we also specify the width of the connecting rails and the used metals:
\luafilelisting[firstline = 1, lastline = 12]{code/momcap.lua}
The parameter definition also shows how you can use better names for displaying: Simply write them in parantheses.
When listing the defined parameters of a cell, the display names are used, but within the cell the regular names are significant.
The parameters are stored in a lua table and can be accessed in two ways:
\luainline{_P.fingers} and \luainline{_P["fingers"]}.
Usually, the first way is easier, but it requires the parameter name to be a valid lua identifier.
Names like \luainline{foo-bar} (with a hyphen) are not valid identifiers.
In this case, the second way would have to be used.

In \luainline{layout()} we  loop over all metals to draw the fingers.
We don't have to create every finger separately, with \luainline{geometry.rectangle} and the multiple capabilities this becomes very simple.
Since the upper and lower fingers are one-off and \luainline{geometry.rectangle} centeres all objects, we only have to move them a little bit up/down.
This is done with the corresponding arguments to \luainline{geometry.rectangle} (note that \luainline{//} denotes floor division in lua):
\luafilelisting[widthgobble = 4, firstline = 17, lastline = 31]{code/momcap.lua}
We create two arrays of fingers, one for the \enquote{upper plate}, one for the \enquote{lower plate}. All fingers have the same width, height and pitch. For the
upper plate, we use one more finger, the placement in \luainline{geometry.rectangle} automatically arranges them centered, so that this \enquote{just works}.  The
ypitch for \luainline{geometry.rectangle} is \num{0}, which is ok since we only have a yrep of \num{1}.

The rails connecting the fingers are created in a similar manner:
\luafilelisting[widthgobble = 4, firstline = 32, lastline = 40]{code/momcap.lua}

What remains is the drawing of the vias between the metals.
For this we introduce a new \luainline{geometry} function: \luainline{geometry.via}.
It takes a rectangular area and creates individual cuts as well as surrounding metals.
There has to be some technology translation for this (proper layer generation as well as calculating the proper geometry of the cuts).
The details on this are not important for this discussion.
It is covered more in-depth in the technology translation manual.
For this case it is enough to know that an appropriate and manufacturable amount of via cuts is placed within this rectangular area.
Since the region is a rectangular, \luainline{geometry.via} takes almost the same arguments as \luainline{geometry.rectangle}.
Only the metal layer is changed into two indices for the first and the last metal of the stack.
This means that \luainline{geometry.via} does \emph{not} expect a generic layer as input.
All layer creation is done by the function itself.
Furthermore, we don't have to specify the individual vias between each layer in the stack, this is resolved later by the technology translation.
For the capacitor, the vias are placed in the rails:
\luafilelisting[widthgobble = 4, firstline = 42, lastline = 49]{code/momcap.lua}
With this the pcell is finished.
A cell similar to this is bundled in this release of openPCells (\texttt{cells/passive/capacitor/mom.lua}).
A few optimizations and additional parameters are added, but the here shown implementation is the basic structure of this capacitor.

\subsection{Octagonal Inductor}
RF designs often require on-chip inductors, which usually are built in an octagonal shape due to angle restrictions in most technologies (no true circles or
better approximations available).
We will show how to built a differential (symmetric) octagonal inductor with a variable number of turns (integers).
We will skip some basic techniques that we already discussed a few times such as setting up the cell body, cell parameters and main object.
Look into \texttt{cells/passive/inductor/octagonal.lua} for the defined parameters.

An inductor is basically a wire (a \emph{path}) routed in a special manner, therefore we will describe the inductor as a \luainline{path}.
This is a series of points that describe a line with a certain width.
To create a path, we have to pass the points to \luainline{geometry.path}, which we will store in a \luainline{table}.
The cell for the octagonal inductor requries some calculations for the right point positions and uses some helper functions.
We won't discuss the entire cell here as some issues are not important for general advice on building cells.
The main purpose is to show how to handle point lists and how to draw paths.

The inductor has the number of turns as a parameter.
For every turn the points for one half of the turn are calculated, then the path is drawn twice, one time with a mirrored version of the points.
\luafilelisting[widthgobble = 8, firstline = 30, lastline = 32]{../../../cells/passive/inductor/octagonal.lua}
The points are stored in the \luainline{table pathpts}, \luainline{util.make_insert_xy} is a helper function, that returns a function that appends/prepends points to an array. It's purpose is to simplify code, one
might as well just use \luainline{table.insert}.

Then we add points:
\luafilelisting[widthgobble = 8, firstline = 34, lastline = 39]{../../../cells/passive/inductor/octagonal.lua}
Now the cell adds points for the underpass (for the crossing of both sides) as well as the extension for the connections.
This discussion will skip these parts as they don't add any value for learning about \luainline{geometry.path}.
The entire code generating the path points is a bit complex and involves some trigonometric calculations.

After the points are assembled, we can create the path. The cell only draws half of the inductor, so we draw the path twice, one time with mirrored points (notice
\luainline{util.xmirror(pathpts)} in the second line):
\luafilelisting[widthgobble = 8, firstline = 89, lastline = 90]{../../../cells/passive/inductor/octagonal.lua}
The \luainline{geometry.path} function takes five arguments: the cell, the layer, the points of the path, the width and whether to use a miter- or a bevel-join. Bevel-join is
default, so \luainline{true} is specified for a miter-join.
The layers where created earlier as
\luafilelisting[widthgobble = 4, firstline = 20, lastline = 21]{../../../cells/passive/inductor/octagonal.lua}

%\subsection{References and Inheritance}
%In order to be able to build larger layouts, it is very useful to re-use cells in hierarchies (for instance, a current mirror is made up of several transistors).
%It would be a good decision to build everything from scratch.
%Therefore, openPCells offers some basic support for such things.
%We will look at logic gates to illustrate the different options.
%All gates are built from transistors, so we will assume for now that there is a cell to place one.
%Furthermore, digital designs mostly (always?) use a few geometry parameters for all cells, such as the gate length.
%It makes sense to store this in one place so we can redefine it for all cells in a hierarchy, if we want to change that.
%In the supplied logic cell family (\texttt{cells/stdcells}), this is handled by the \texttt{stdcells/base} cell.
%It is a abstract cell, that is, it does not define a layout function, so it can't be called.
%But it does store the relevant parameters, which get referenced by the top cells (and temporarily changed).
%Other cells then access the parameters, for instance \texttt{stdcells/not\_gate.lua}:
%\luafilelisting[firstline = 1, lastline = 11]{../../../cells/stdcells/not_gate.lua}
%This cell has only has a small number of parameters but uses the supplied parameters of \texttt{stdcells/base.lua} for the layout function. The parameters are used
%implicitly by creating other cells that reference these parameters, and explicitly by accessing them with \luainline{pcell.get_parameters}. In order to do this,
%a cell has to reference that cell with \luainline{pcell.reference_cell}. The referenced parameters reflect the current values, that is if a top cell instantiates the
%inverter, it can overwrite the values of referenced parameters, affecting all sub cells. This is achieved by calling \luainline{pcell.push_overwrites}, which can
%be seen in \texttt{stdcells/1\_inv\_gate.lua} (basic cell for and/or):
%\luafilelisting[widthgobble = 4, firstline = 13, lastline = 13]{../../../cells/stdcells/1_inv_gate.lua}
%Cells that need to prevent parameters being changed from the toplevel have to include guards against that, which is exactly what can be seen in the previous
%listing. The overwrites are stack-based, so the last \luainline{push_overwrites} counts. In \texttt{stdcells/1\_inv\_gate.lua}, rightdummies can not be changed from
%outside anymore.
%\subsection{Translation, Object Placement and the Alignment Box}
%We already saw the \luainline{translate} object method to move objects. For more complex layouts, a better method exists. Cells can have anchors, that is, points
%at certain places in the layout which can be referenced. You can ask for the location of an anchor from an object (\luainline{get_anchor}) and you can move a
%cell so that the specified anchor lies at a certain point (\luainline{move_anchor}). Let's see an example:
%\luafilelisting[widthgobble = 8, firstline = 62, lastline = 64]{../../../cells/stdcells/harness.lua}
%The used anchors have to be present in the specific cell, and it is up to the designer of that cell to provide the needed anchors.
%
%Of course do anchors move if an object is moved, but they also move if the cell is flipped/mirror/rotated etc. This ensures that the anchors are always at the
%right place in the layout. However, in certain cases, the opposite behaviour is useful: If you want to, say, place two digital standard cells next to each other,
%you can use appropriate anchors for left and right (for instance at the leftmost and rightmost source/drain) and align them at these points. This works fine
%until a cell is mirrored at the y-axis. Then the anchor left becomes right and the other way around. This means that cells generating such layouts need to handle
%flipped/rotated/mirrored cells differently, which is a nuisance. There is a special set of anchors for exactly this problem: the alignment box. This box is also
%defined by the cell designer and in effect it provides the special anchors left, right, top, bottom and sensible combinations of those (e.g. topleft, NOT
%leftright). The alignment box undergoes translation, but not rotation/flipping/mirroring. This allows the following (from \texttt{stdcells/dff.lua}):
%\luafilelisting[widthgobble = 4, firstline = 75, lastline = 78]{../../../cells/stdcells/dff.lua}
%Notice the calls in the last two lines, where the cell gets flipped in x direction (mirrored at the y axis) but still the left anchor is used for alignment (the
%cell is placed right of the isogate).
%
%The above example shows another important fact about object transformation: Translation is always applied last (after rotation/flipping/mirroring). This is
%contrary to many other graphical programs, where for instance rotation is applied with the origin is center. In opc, the order of the transformation statements
%does not matter. This is intentional, as this is what is usually needed in layouts and simplifies the pcell code. The other behaviour can always be achieved by
%appropriate translation.

\subsection{Cell Hierarchies}
Layouts of integrated circuits usually make great use of repetition/reuse of cells.
For instance, a shift register uses the same flip flop over and over again.
Creating \emph{flat} layouts (that is, layouts without any hierarchies) for these cells can be quite resource-intense
More shapes have to be calculated by opc and the resulting layout is very likely to be larger in file size than a hierarchical one.
Therefore, opc supports hierachical layouts.
Instantiations in a cell of other cells/layouts are called \emph{children}.
They are light-weight handles to full cells and don't contain any flat shapes of their own.
As example a layout that uses a sub-cell 1000 times it only has to store 1000 handles, but not 1000 versions of the same layout.
A layout that makes proper use of hierarchy can me multiple magnitudes faster in processing than a flat version.

Each child has a reference it points to, which is created automatically by adding a child to a cell.
As an example, let's create the following hierarchy:
\begin{center}
    \begin{tikzpicture}
        [
            cell/.style = {draw, rectangle, very thick, align = center},
            %on grid,
            node distance = 0.5cm and 0.5cm
        ]
        \node[cell] (toplevel) {Toplevel\\\emph{Toplevel}};
        \node[cell, below = of toplevel] (sub) {Sub\\\emph{Sub}};
        \node[cell, below left = of sub] (subsub1) {SubSub\\\emph{SubSub1}};
        \node[cell, below right = of sub] (subsub2) {SubSub\\\emph{SubSub2}};
        \draw[very thick] (toplevel) -- (sub);
        \draw[very thick] (sub) -- (subsub1);
        \draw[very thick] (sub) -- (subsub2);
    \end{tikzpicture}
\end{center}
The upright name shows the name of the cell (which can be re-used), the italic name is the instance name (this has to be unique).
In this example, the top-level cell instantiates another cell (sub), which in turn instantiates two other cells (subsub).
In order to create this hierarchy in code, we have to do the following steps:
First we create all cells (which are called \emph{references}):
\luafilelisting[firstline = 1, lastline = 3]{code/hierarchy_example.lua}
After that, we simply add the respective cells as children:
\luafilelisting[firstline = 4, lastline = 8]{code/hierarchy_example.lua}
It is important not to confuse the cell names here.
All functions that create proper cells (objects) such as \luainline{pcell.create_layout} or \luainline{object.create} must be supplied with a name for that cell.
Functions for adding children to objects (currently the object methods \luainline{add_child} and \luainline{add_child_array}) take an optional parameter for the instance name\footnote{This instance name is not supported by all exports. For example, GDSII has no notion of an instance name}.
If this name is not given, an automatically generated name will be used.

We can see a simple example of proper instance naming in \texttt{analog/ringoscillator.lua}.
Here, \luainline{string.format} is used to generate unique instance names for the individual inverters of a ring oscillator.
First, the inverter reference (the actual cell) is created.
This inverter is a CMOS structure with some additional wires, so the basic structure of the inverter is based on \luainline{basic/cmos}.
For brevity, the additional drawings etc. are not shown here.
\luafilelisting[widthgobble = 4, firstline = 93, lastline = 97]{../../../cells/analog/ringoscillator.lua}
Then the inverter reference (which is only generated once) can be \emph{instantiated} multiple times, which happens within a loop in this case:
\luafilelisting[widthgobble = 4, firstline = 110, lastline = 116]{../../../cells/analog/ringoscillator.lua}
The above example creates a number of inverters (depending on the parameter \luainline{numinv}).
To add a child, \luainline{add_child} is used, which expects a full object as reference and an instance name.
Here, the single reference is instantiated multiple times, therefore the instance name is modified in every call.
Additionally, the cells are left-right aligned to build a proper layout.

In the above ring oscillator example, the return value of \luainline{add_child} is stored in a table.
The return value of \luainline{add_child} is a so-called \emph{proxy object}.
This proxy object behaves like a regular object that it can be moved, rotated and its anchors can be queried (as can be seen in the example).
These operations only operate on small data structures and a very lightweight in general.
It is usually a good idea to put repeated layout structures in sub-cells for them to be re-used, as this very likely leads to a smaller and faster-processed layout.

\section{Cell Scripts}
The previous section discussed the use of pcell definitions based on the functions \luainline{parameters} and \luainline{layout}.
For re-used cells this is a good aproach, but some layouts are handled with more similarity to a stand-alone program.
For this, \emph{cell scripts} are also supported.
For the main part, they function like proper cell files, but cellscripts just describe the content of the layout function of cells.
This means that some parts are more manual, for instance the main object must be created and returned by the user.
An example cell scripts could look like this:
\begin{lualisting}
    local cell = object.create("toplevel")
    geometry.rectangle(cell, generics.metal(1), 100, 100)
    return cell
\end{lualisting}
Cell scripts have the advantage that they don't have to be placed in some path known to opc.
The layout-generation call to opc expects a (absolut or relativ to the calling path) path to the cell script, such as
\begin{shellcode}
    opc --technology opc --export gds --cellscript path/to/cell.lua
\end{shellcode}
\section{Available PCells}
In the following subsections, all available cells will be documented. The current status is rather a poor one, but work is ongoing.
\subsection{Transistor}
The transistor might be the most important cell and currently it's also definitely the most complex one. Therefore, this documentation starts with a description of
the goal. Figure \ref{fig:transistor} shows an example with all geometrical parameters, a summary of all parameters can be found in table \ref{tab:transistor}. The
cell draws a number of gates on top of an active area (with some implant/well/etc. markers).
\begin{figure}[htb]
    \centering
    \definecolor{activegreen}{RGB}{0,204,102}
    \begin{tikzpicture}
        [
            %marker/.style = {draw = yellow, pattern = dots, pattern color = yellow},
            %active/.style = {draw = activegreen, pattern = grid, pattern color = activegreen},
            %gate/.style = {draw = red, pattern = crosshatch, pattern color = red},
            %metal/.style = {draw = blue, pattern = crosshatch dots, pattern color = blue},
            marker/.style = {draw = none, fill = yellow, opacity = 0.5},
            active/.style = {draw = none, fill = activegreen},
            gate/.style = {draw = none, fill = red},
            metal/.style = {draw = none, fill = blue, opacity = 0.5},
            annotation/.style = {<->, >=stealth, very thick}
        ]
        \def\fingers{4}
        \def\flength{0.5}
        \def\fwidth{4}
        \def\fspace{2}
        \def\gtopext{1}
        \def\gbotext{1}
        \def\gatestrwidth{0.75}
        \def\sdwidth{0.8}
        \def\actext{1.0}
        % active marker
        \draw[marker] ({-0.5 * \fingers * (\flength + \fspace) - \actext}, {-0.5 * \fwidth - \actext}) rectangle
                      ({ 0.5 * \fingers * (\flength + \fspace) + \actext}, { 0.5 * \fwidth + \actext});
        % active
        \draw[active] ({-0.5 * \fingers * (\flength + \fspace)}, {-0.5 * \fwidth}) rectangle
                      ({ 0.5 * \fingers * (\flength + \fspace)}, { 0.5 * \fwidth});
        % active
        \draw[active] ({-0.5 * \fingers * (\flength + \fspace)}, {-0.5 * \fwidth}) rectangle ({0.5 * \fingers * (\flength + \fspace)}, {0.5 * \fwidth});
        % gates
        \foreach \x in {1, ..., \fingers}
        {
            \draw[gate] ({\fspace * (\x - 0.5 * (\fingers - 1) - 1) - 0.5 * \flength}, { -0.5 * \fwidth - \gbotext}) rectangle
                        ({\fspace * (\x - 0.5 * (\fingers - 1) - 1) + 0.5 * \flength}, {  0.5 * \fwidth + \gtopext});
        }
        % metal
        \draw[metal] ({-0.5 * \fingers * (\flength + \fspace)}, {-0.5 * \gatestrwidth + 0.5 * \fwidth + \gtopext}) rectangle
                     ({ 0.5 * \fingers * (\flength + \fspace)}, { 0.5 * \gatestrwidth + 0.5 * \fwidth + \gtopext});
        \draw[metal] ({-0.5 * \fingers * (\flength + \fspace)}, {-0.5 * \gatestrwidth - 0.5 * \fwidth - \gbotext}) rectangle
                     ({ 0.5 * \fingers * (\flength + \fspace)}, { 0.5 * \gatestrwidth - 0.5 * \fwidth - \gbotext});
        \foreach \x in {0, ..., \fingers}
        {
            \draw[metal] ({\fspace * (\x - 0.5 * \fingers) - 0.5 * \sdwidth}, { -0.5 * \fwidth}) rectangle
                         ({\fspace * (\x - 0.5 * \fingers) + 0.5 * \sdwidth}, {  0.5 * \fwidth});
        }
        % annotations
        \draw[annotation] ({-0.5 * \fingers * (\flength + \fspace)}, {-0.5 * \fwidth}) -- node[left] {fwidth} ({-0.5 * \fingers * (\flength + \fspace)}, {0.5 * \fwidth});
        \draw[annotation] ({\fspace * (1 - 0.5 * (\fingers - 1) - 1) - 0.5 * \flength}, {-0.25 * \fwidth}) -- node[below] {flength} ++(\flength, 0);
        \draw[annotation] ({\fspace * (1 - 0.5 * (\fingers - 1) - 1) + 0.5 * \flength}, { 0.25 * \fwidth}) -- node[below] {fspace}  ++({\fspace - \flength}, 0);
        \draw[annotation] ({\fspace * (\fingers - 0.5 * (\fingers - 1) - 1) + 0.5 * \flength}, { -0.5 * \fwidth - \gbotext}) -- node[right] {gbotext} ++(0,  \gbotext);
        \draw[annotation] ({\fspace * (\fingers - 0.5 * (\fingers - 1) - 1) + 0.5 * \flength}, {  0.5 * \fwidth + \gtopext}) -- node[right] {gtopext} ++(0, -\gbotext);
        \draw[annotation] ({\fspace * (3 - 0.5 * \fingers) - 0.5 * \sdwidth}, { 0.25 * \fwidth}) -- node[below] {sdwidth}  ++(\sdwidth, 0);
        \draw[annotation] ({ 0.5 * \fingers * (\flength + \fspace)}, 0) -- node[above] {actext} ++(\actext, 0);
    \end{tikzpicture}
    \caption{Overview of the transistor}
    \label{fig:transistor}
\end{figure}
Furthermore, it draws some metals and vias (not shown in figure \ref{fig:transistor}) in the source/drain regions and for gate contacts.

\begin{table}[htb]
    \centering
    \begin{tabular}{llc}
        \toprule
        Parameter & Meaning & Default \\
        \midrule
        channeltype     & Type of Transistor & "nmos" \\
        oxidetype       & Oxide Thickness Index & 1 \\
        vthtype         & Threshold Voltage Index & 1 \\
        fingers         & Number of Fingers& 4 \\
        fwidth          & Finger Width & 1.0 \\
        gatelength      & Finger Length & 0.15 \\
        fspace          & Space between Fingers & 0.27 \\
        actext          & Left/Right Extension of Active Area & 0.03 \\
        sdwidth         & Width of Source/Drain Metals & 0.2 \\
        sdconnwidth     & Width of Source/Drain Connection Rails Metal & 0.2 \\
        sdconnspace     & Space of Source/Drain Connection Rails Metal & 0.2 \\
        gtopext         & Gate Top Extension & 0.2 \\
        gbotext         & Gate Bottom Extension & 0.2 \\
        typext          & Implant/Well Extension around Active & 0.1 \\
        cliptop         & Clip Top Marking Layers (Implant, Well, etc.) & false \\
        clipbot         & Clip Bottom Marking Layers (Implant, Well, etc.) & false \\
        drawtopgate     & Draw Top Gate Strap & false \\
        drawbotgate     & Draw Bottom Gate Strap & false \\
        topgatestrwidth && 0.12 \\
        topgatestrext   && 1 \\
        botgatestrwidth && 0.12 \\
        botgatestrext   && 1 \\
        topgcut         & Draw Top Poly Cut & false \\
        botgcut         & Draw Bottom Poly Cut & false \\
        connectsource   & Connect all Sources together & false \\
        connectdrain    & Connect all Drains together & false\\
        \bottomrule
    \end{tabular}
    \caption{Summary of Transistor Parameters}
    \label{tab:transistor}
\end{table}

\cleardoublepage

\section{API Documentation}

\subsection{geometry Module}

\begin{APIfunc}{rectangle(cell, layer, width, height, xshift, yshift, xrep, yrep, xpitch, ypitch)}
    Create a rectangular shape with the given width and height.
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generic}
            Layer of the generated rectangle;
        \parameter{width}{integer}
            Width of the rectangle. Must be even.;
        \parameter{height}{integer}
            Height of the rectangle. Must be even.;
        \parameterdefault{xshift}{0}{integer}
            Optional shift in x direction.;
        \parameterdefault{yshift}{0}{integer}
            Optional shift in y direction.;
        \parameterdefault{xrep}{1}{integer}
            Optional number of repetitions in x direction.
            Rectangles are shifted so that an equal number is left and right.;
        \parameterdefault{yrep}{1}{integer}
            Optional number of repetitions in y direction.
            Rectangles are shifted so that an equal number is left and right.;
        \parameterdefault{xpitch}{0}{integer}
            Optional pitch in x direction, used for repetition in x.;
        \parameterdefault{ypitch}{0}{integer}
            Optional pitch in y direction, used for repetition in y.;
    \end{APIparameters}
\end{APIfunc}

\begin{APIfunc}{rectanglebltr(cell, layer, bl, tr, xrep, yrep, xpitch, ypitch)}
    Create a rectangular shape defined by the bottom-left and the top-right corner.
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generic}
            Layer of the generated rectangle;
        \parameter{bl}{point}
            Bottom-left (bl) point of the rectangle;
        \parameter{tr}{point}
            Top-right (tl) point of the rectangle;
        \parameterdefault{xrep}{1}{integer}
            Optional number of repetitions in x direction.
            Rectangles are shifted so that an equal number is left and right.;
        \parameterdefault{yrep}{1}{integer}
            Optional number of repetitions in y direction.
            Rectangles are shifted so that an equal number is left and right.;
        \parameterdefault{xpitch}{0}{integer}
            Optional pitch in x direction, used for repetition in x.;
        \parameterdefault{ypitch}{0}{integer}
            Optional pitch in y direction, used for repetition in y.;
    \end{APIparameters}
\end{APIfunc}

\subsection{Object Module}
\subsection{Shape Module}
\subsection{Pointarray Module}
\subsection{Point Module}
\end{document}

% vim: ft=tex
